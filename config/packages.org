#+TITLE: packages.org
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent

* Core UX
#+begin_src emacs-lisp
;; which-key: muestra las teclas disponibles tras un prefijo.
(use-package which-key
  :hook (after-init . which-key-mode)
  :custom
  (which-key-idle-delay 0.4))

;; Ivy: completado ligero para todo el minibuffer.
(use-package ivy
  :diminish
  :hook (after-init . ivy-mode)
  :bind (:map ivy-minibuffer-map
         ("C-n" . ivy-next-line)
         ("C-p" . ivy-previous-line)
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         :map ivy-switch-buffer-map
         ("C-n" . ivy-next-line)
         ("C-p" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-n" . ivy-next-line)
         ("C-p" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-count-format "(%d/%d) "))

;; Counsel: comandos enriquecidos con interfaz Ivy
(use-package counsel
  :after ivy
  :bind (("M-x"     . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("M-y"     . counsel-yank-pop)
         ("C-x b"   . counsel-switch-buffer)
         ("C-x C-r" . counsel-recentf)
         ("C-c k"   . counsel-rg)
         ("C-h v"   . counsel-describe-variable)
         ("C-h f"   . counsel-describe-function)
         ("C-h b"   . counsel-descbinds)
	 ("C-c b"   . counsel-bookmark)
         :map minibuffer-local-map
         ("C-r" . counsel-minibuffer-history))
  :config
  (setq ivy-initial-inputs-alist nil)
  (setq counsel-find-file-ignore-regexp
         "\\(?:__pycache__/\\|\\.ipynb_checkpoints/\\)"))

;; Helpful: buffers de ayuda enriquecidos, integrados con Counsel
(use-package helpful
  :after counsel
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-symbol]   . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-command]  . helpful-command)
  ([remap describe-key]      . helpful-key))

;; Swiper: búsqueda incremental en buffer con interfaz Ivy
(use-package swiper
  :after ivy
  :bind (("C-s"     . swiper-isearch)
         ("C-r"     . swiper-isearch-backward)
         ("C-S-s"   . swiper)
         ("M-s ."   . swiper-thing-at-point))
  :custom
  (swiper-goto-start-of-match t)
  (swiper-action-recenter t))

;; Ivy-Rich: columnas extra (modo, proyecto, ruta, tamaño, etc.) en Ivy/Counsel
(use-package ivy-rich
  :after counsel
  :init
  (ivy-rich-mode 1)
  :custom
  (ivy-format-functions-alist
   '((t . ivy-format-function-line)))
  ;; Rutas abreviadas (~/… en lugar de /home/…)
  (ivy-rich-path-style 'abbrev)
  ;; Cachea el root del proyecto para acelerar switch-buffer en repos grandes
  :config
  (when (fboundp 'ivy-rich-project-root-cache-mode)
    (ivy-rich-project-root-cache-mode +1)))

;; Smex: prioriza los comandos más usados en M-x (lo aprovecha counsel-M-x)
(use-package smex
  :after counsel
  :init
  (smex-initialize)
  :custom
  (smex-save-file (expand-file-name "var/smex-items" user-emacs-directory)))

;; prescient: ranking por uso (frecencia) + persistencia del historial
(use-package prescient
  :custom
  (prescient-save-file (expand-file-name "var/prescient-save.el" user-emacs-directory))
  :config
  (prescient-persist-mode +1))

;; ivy-prescient: aplica ese ranking y (opcionalmente) filtrado en Ivy/Counsel
(use-package ivy-prescient
  :after (ivy prescient)
  :custom
  (ivy-prescient-enable-sorting t)
  (ivy-prescient-enable-filtering t)
  :config
  (ivy-prescient-mode +1))

;; Whitespaces para que se vean
(use-package whitespace
  :init
  (setq whitespace-style '(face space-mark trailing))
  (setq whitespace-display-mappings '((space-mark 32 [183] [46])))
  (setq whitespace-space-regexp "\\(^ +\\| +$\\)")
  :hook ((prog-mode . whitespace-mode)))

;; wgrep: editar resultados de grep/rg directamente y aplicar cambios a los archivos
(use-package wgrep
  :after counsel
  :commands (wgrep-change-to-wgrep-mode)
  :config
  ;; Hace que al guardar con C-x C-s se apliquen los cambios sin preguntar
  (setq wgrep-auto-save-buffer t))

;; Selección incremental
(use-package expand-region
  :commands (er/expand-region er/contract-region)
  :bind (("C-=" . er/expand-region)
         ("C--" . er/contract-region))
  :custom
  (expand-region-fast-keys-enabled t)
  (expand-region-contract-fast-key "-")
  (expand-region-reset-fast-key "0")
  (expand-region-skip-whitespace t)
  (expand-region-smart-cursor t)
  (expand-region-subword-enabled t))

;; winner-mode: deshacer/rehacer disposición de ventanas
(use-package winner
  :init
  (winner-mode 1))
#+end_src

* Proyectos, tree y arhcivos
#+begin_src emacs-lisp
;; Projectile con Ivy como frontend
(use-package projectile
  :demand t
  :custom
  	(projectile-completion-system 'ivy)
  	(projectile-indexing-method 'alien)
  	(projectile-enable-caching t)
  :bind-keymap
  	("C-c p" . projectile-command-map)   ;; <-- evita el void-variable
  :init
  	(setq projectile-project-search-path '("~/Proyectos" "~/Sandbox"))
  :config
  	(projectile-mode 1))

;; Counsel projectile
(use-package counsel-projectile
  :after (projectile counsel)
  :init
  (setq projectile-switch-project-action #'counsel-projectile)
  :bind
  (:map projectile-command-map
        ("p" . counsel-projectile-switch-project)   ;; C-c p p
        ("f" . counsel-projectile-find-file)        ;; C-c p f
        ("r" . counsel-projectile-recentf)          ;; C-c p r
        ("g" . counsel-projectile-rg)               ;; C-c p g
        ("b" . counsel-projectile-switch-to-buffer) ;; C-c p b
        ("k" . project-kill-buffers)                ;; C-c p k
        ("i" . projectile-invalidate-cache))        ;; C-c p i
  :config
  (counsel-projectile-mode 1))


;; Treemacs
(use-package treemacs
  :commands (treemacs treemacs-select-window)
  :init
  (setq treemacs-width 25
        treemacs-position 'left
        treemacs-is-never-other-window t
        treemacs-indentation 1)
  :config
  (treemacs-follow-mode 1)
  (treemacs-filewatch-mode 1)
  (treemacs-git-mode 'deferred)
  (treemacs-resize-icons 13))

(use-package treemacs-projectile :after (treemacs projectile))

;; Nerd Icons 
(use-package nerd-icons
  :init
  (setq nerd-icons-scale-factor 0.5))

(use-package treemacs-nerd-icons
  :after (treemacs nerd-icons)
  :config
  (treemacs-load-theme "nerd-icons"))

;; Sesión global persistente
(use-package desktop
  :ensure nil
  :init
  (let ((dir (expand-file-name "var/desktop/" user-emacs-directory)))
    (setq desktop-dirname             dir
          desktop-path                (list dir)
          desktop-save                t
          desktop-auto-save-timeout   60
          desktop-load-locked-desktop t)
    (unless (file-directory-p dir) (make-directory dir t)))
  :config
  (desktop-save-mode 1)
  (add-hook 'kill-emacs-hook #'desktop-save-in-desktop-dir))
#+end_src

* Terminales y multi term
#+begin_src emacs-lisp
;; vterm + multi-vterm (igual que ya tenés)
(use-package vterm
  :commands (vterm)
  :custom
  (vterm-shell (or (getenv "SHELL") "/bin/bash"))
  (vterm-max-scrollback 5000)
  (vterm-kill-buffer-on-exit t))

;; multi-vterm: agrego el comando project
(use-package multi-vterm
  :after vterm
  :commands (multi-vterm multi-vterm-next multi-vterm-prev multi-vterm-project))

;; vterm-toggle: panel inferior fijo (30%)
(use-package vterm-toggle
  :after vterm
  :config
  (setq vterm-toggle-fullscreen-p nil)
  ;; Mostrar SIEMPRE los buffers vterm en una ventana lateral abajo (30%):
  (add-to-list 'display-buffer-alist
               '((lambda (buffer-or-name _)
                   (let ((buf (get-buffer buffer-or-name)))
                     (with-current-buffer buf
                       (or (derived-mode-p 'vterm-mode)
                           (string-prefix-p vterm-buffer-name (buffer-name buf))))))
                 (display-buffer-reuse-window display-buffer-in-side-window)
                 (side . bottom)
                 (reusable-frames . visible)
                 (window-height . 0.3))))
#+end_src

* Git y revision
#+begin_src emacs-lisp
;; Magit: interfaz Git completa
(use-package magit
  :commands (magit-status magit-dispatch magit-file-dispatch magit-list-repositories)
  :custom
  ;; Ventanas: todo en la misma, menos los diffs
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  ;; Guardar buffers del repo sin preguntar antes de refrescar/operar
  (magit-save-repository-buffers 'dontask)
  ;; Directorios a escanear para magit-list-repositories
  (magit-repository-directories '(("~/Proyectos" . 2) ("~/Sandbox" . 1))))

;; Forge
(use-package forge
  :after magit)

;; magit-todos
(use-package magit-todos
  :after magit
  :hook (magit-status-mode . magit-todos-mode)
  :custom
  (magit-todos-keywords '("TODO" "FIXME" "BUG" "HACK" "REVIEW" "NOTE")))

;; diff-hl: marcas en el fringe + navegación/revert por hunk
(use-package diff-hl
  :hook ((dired-mode . diff-hl-dired-mode)
         (magit-post-refresh . diff-hl-magit-post-refresh))
  :config
  (global-diff-hl-mode 1)    ;; resalta cambios en todos los buffers versionados
  (diff-hl-flydiff-mode 1))  ;; actualiza “on the fly” sin guardar
#+end_src

* Edicion productiva
#+begin_src emacs-lisp
;; crux: utilidades prácticas de edición y archivos
(use-package crux
  :bind
  ([remap move-beginning-of-line] . crux-move-beginning-of-line)
  (("C-c x d" . crux-duplicate-current-line-or-region)
   ("C-c x c" . crux-duplicate-and-comment-current-line-or-region)
   ("C-c x o" . crux-smart-open-line)
   ("C-c x O" . crux-smart-open-line-above)
   ("C-c x k" . crux-smart-kill-line)
   ("C-c x K" . crux-kill-other-buffers)
   ("C-c x r" . crux-rename-file-and-buffer)
   ("C-c x D" . crux-delete-file-and-buffer)
   ("C-c x n" . crux-cleanup-buffer-or-region)
   ("C-c x I" . crux-find-user-init-file)))

;; multiple-cursors: edición paralela
(use-package multiple-cursors
  :init
  (setq mc/always-run-for-all t)
  (setq mc/list-file (expand-file-name "var/.mc-lists.el" user-emacs-directory))
  :bind (("C-c m l" . mc/edit-lines)
         ("C-c m b" . mc/edit-beginnings-of-lines)
         ("C-c m e" . mc/edit-ends-of-lines)
         ("C->"     . mc/mark-next-like-this)
         ("C-<"     . mc/mark-previous-like-this)
         ("C-c m a" . mc/mark-all-like-this)
         ("C-c m r" . set-rectangular-region-anchor)))

;; avy: saltos rápidos
(use-package avy
  :bind ( :map search-map
          ("a" . avy-goto-char-timer)
          ("l" . avy-goto-line)
          ("w" . avy-goto-word-1))
  :custom
  (avy-background t)
  (avy-timeout-seconds 0.35))

;; smartparens
(use-package smartparens
  :hook ((prog-mode . smartparens-mode)
         (org-mode  . smartparens-mode))
  :config
  (require 'smartparens-config)
  (show-smartparens-global-mode 1)
  ;; Modo estricto = estructura siempre balanceada (como paredit)
  (smartparens-strict-mode 1)
  ;; Evitar choques con electric-pair localmente
  (add-hook 'smartparens-mode-hook (lambda () (electric-pair-local-mode -1))))

;; Snippets
(use-package yasnippet
  :hook ((prog-mode . yas-minor-mode)
         (org-mode  . yas-minor-mode))
  :init
  ;; Tu colección personal primero, después la de comunidad
  (setq yas-snippet-dirs
        (list (expand-file-name "snippets" user-emacs-directory)
              (expand-file-name "straight/repos/yasnippet-snippets/snippets"
                                user-emacs-directory)))
  :config
  (yas-reload-all))

(use-package yasnippet-snippets
  :after yasnippet)

;; Apheleia: formateo asíncrono, estable al punto
(use-package apheleia
  :init
  (with-eval-after-load 'apheleia
    (setf (alist-get 'isort apheleia-formatters) '("isort" "--stdout" "-"))
    (setf (alist-get 'python-mode apheleia-mode-alist) '(isort black)))
  :config
  (apheleia-global-mode +1)
  (add-hook 'apheleia-skip-functions #'jinxx/apheleia-skip-large-file))

;; Mover línea o región arriba/abajo (estilo IDE)
(use-package move-text
  :bind (("M-S-<up>"   . move-text-up)
         ("M-S-<down>" . move-text-down))
  :config
  (move-text-default-bindings))

#+end_src

* Lenguajes y datos
#+begin_src emacs-lisp
;; Markdown: edición de archivos .md
(use-package markdown-mode
  :mode ("\\.md\\'" . gfm-mode))
#+end_src

* Confirmación
#+begin_src emacs-lisp
(message "packages.org cargado")
#+end_src

